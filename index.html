<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>DON'T LOOK BACK — First Person (Leaderboard)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#000;color:#eee;font-family:monospace;overflow:hidden}
  /* Menu UI */
  #menu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at 40% 20%, rgba(255,255,255,0.03), #000 60%);}
  #menuBox{width:360px;padding:18px;background:rgba(0,0,0,0.7);border-radius:8px;border:1px solid rgba(255,255,255,0.06);box-shadow:0 10px 40px rgba(0,0,0,0.8);text-align:center}
  h1{margin:0 0 6px;font-size:28px;color:#9ff3e0;letter-spacing:1px}
  .muted{opacity:0.7;font-size:13px;margin-bottom:8px}
  button{display:block;margin:10px auto;padding:10px 14px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:inherit;cursor:pointer;border-radius:6px}
  button:hover{background:rgba(255,255,255,0.12)}
  #leaderboardPanel{display:none;margin-top:10px;text-align:left;background:rgba(0,0,0,0.5);padding:10px;border-radius:8px}
  ol{padding-left:18px;margin:6px 0}
  /* Game container */
  #game{position:fixed;inset:0;display:none}
  /* HUD */
  #hud{position:fixed;left:14px;top:14px;z-index:10;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);font-size:13px}
  /* Death overlay */
  #deathOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:50;flex-direction:column}
  #deathBox{background:rgba(10,10,10,0.9);padding:18px;border-radius:10px;border:1px solid rgba(255,0,0,0.06);text-align:center}
  input[type=text]{padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);width:220px;margin-top:8px}
  small.note{display:block;color:#bbb;margin-top:8px;font-size:12px}
</style>
</head>
<body>

<!-- MENU -->
<div id="menu">
  <div id="menuBox">
    <h1>DON'T LOOK BACK</h1>
    <div class="muted">Slow. Heavy. Keep your eyes open.</div>

    <button id="btnStart">ENTER</button>
    <button id="btnLeaderboard">LEADERBOARD</button>

    <div id="leaderboardPanel">
      <div style="opacity:.8;margin-bottom:8px">TOP PATIENTS</div>
      <ol id="leaderboardList"><li>—</li></ol>
      <button id="btnCloseBoard">BACK</button>
    </div>

    <div style="margin-top:12px;font-size:12px;color:#cfcfcf;opacity:0.8">Tip: look at dark shapes. Don't stop moving too long.</div>
  </div>
</div>

<!-- GAME CONTAINER -->
<div id="game"></div>

<!-- HUD -->
<div id="hud" style="display:none">
  <div>Time: <span id="time">0.0</span>s</div>
  <div>Sanity: <span id="san">1.00</span></div>
  <div style="font-size:11px;color:#c4c4c4">WASD to move • Mouse to look • ESC to unlock</div>
</div>

<!-- DEATH / SUBMIT OVERLAY -->
<div id="deathOverlay">
  <div id="deathBox">
    <div id="deathText" style="font-size:18px;color:#ffcccc">YOU DIED</div>
    <div style="margin-top:8px">Survived: <strong id="finalTime">0.0</strong>s</div>
    <input id="playerName" type="text" placeholder="ENTER NAME (max 18 chars)" maxlength="18" />
    <div style="margin-top:10px">
      <button id="submitScoreBtn">SUBMIT SCORE</button>
      <button id="playAgainBtn">PLAY AGAIN</button>
    </div>
    <small class="note" id="submitNote"></small>
  </div>
</div>

<!-- FIREBASE + GAME LOGIC -->
<script type="module">
/* ============================
   FIREBASE (modular) - CONFIGURED
   ============================ */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
import {
  getFirestore,
  collection,
  addDoc,
  query,
  orderBy,
  limit,
  getDocs
} from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

/* === YOUR FIREBASE CONFIG === */
const firebaseConfig = {
  apiKey: "AIzaSyCtK66ANPg24cBOTU9N2jnd_SDExQPqxL4",
  authDomain: "scaryproject-fe9ef.firebaseapp.com",
  projectId: "scaryproject-fe9ef",
  storageBucket: "scaryproject-fe9ef.firebasestorage.app",
  messagingSenderId: "631450445742",
  appId: "1:631450445742:web:f1bc14bb63911dfc4d0a3f"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

// sign in anonymously and expose API
await signInAnonymously(auth);

window.loadLeaderboard = async () => {
  const q = query(collection(db, "leaderboard"), orderBy("score", "asc"), limit(10));
  const snap = await getDocs(q);
  return snap.docs.map(d => ({ id: d.id, ...d.data() }));
};

window.submitScore = async (name, score, extras={}) => {
  // extras can include sessionId, movementDistance
  // simple server-side replacement not possible here; we do client-side checks before calling this.
  await addDoc(collection(db, "leaderboard"), {
    name, score, createdAt: Date.now(), ...extras
  });
};

/* ============================
   SIMPLE GAME (Three.js first-person)
   ============================ */

import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

let renderer, scene, camera;
let playing = false;
let lastTime = 0;
let clockStart = 0;
let survivalSeconds = 0;
let playerMovedDistance = 0;
let prevPlayerPos = new THREE.Vector3();
let sessionId = sessionStorage.getItem('scary_session') || (Math.random().toString(36).slice(2));
sessionStorage.setItem('scary_session', sessionId);
let submittedThisSession = sessionStorage.getItem('scary_submitted') === '1';

const hud = document.getElementById('hud');
const timeEl = document.getElementById('time');
const sanEl = document.getElementById('san');

const deathOverlay = document.getElementById('deathOverlay');
const finalTime = document.getElementById('finalTime');
const playerNameInput = document.getElementById('playerName');
const submitBtn = document.getElementById('submitScoreBtn');
const playAgainBtn = document.getElementById('playAgainBtn');
const submitNote = document.getElementById('submitNote');

const menu = document.getElementById('menu');
const btnStart = document.getElementById('btnStart');
const btnLeaderboard = document.getElementById('btnLeaderboard');
const leaderPanel = document.getElementById('leaderboardPanel');
const leaderList = document.getElementById('leaderboardList');
const btnCloseBoard = document.getElementById('btnCloseBoard');

btnStart.onclick = () => startRun();
btnLeaderboard.onclick = () => openLeaderboard();
btnCloseBoard.onclick = () => closeLeaderboard();

// basic settings
const MOVE_SPEED = 0.03;   // slow
const SENS = 0.0022;
const MIN_SURVIVAL = 5;    // seconds required to submit
const MAX_SCORE = 3600;    // clamp

// three.js setup
function initThree(){
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  document.getElementById('game').appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020203);
  scene.fog = new THREE.Fog(0x020203, 2, 25);

  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 100);
  camera.position.set(0, 1.6, 0);

  // subtle top light
  const topLight = new THREE.PointLight(0xffffff, 0.7, 20);
  topLight.position.set(0,3,0);
  scene.add(topLight);

  // padded cube room (inverted box)
  const roomGeo = new THREE.BoxGeometry(10,5,10);
  // flip faces inside
  roomGeo.scale(-1,1,1);
  const roomMat = new THREE.MeshStandardMaterial({color:0xf6f6f6, roughness:1});
  const room = new THREE.Mesh(roomGeo, roomMat);
  scene.add(room);

  // small blood plane on floor (decor)
  const bloodGeo = new THREE.CircleGeometry(0.6, 16);
  const bloodMat = new THREE.MeshStandardMaterial({color:0x6f0b0b, roughness:0.8});
  const blood = new THREE.Mesh(bloodGeo, bloodMat);
  blood.rotation.x = -Math.PI/2;
  blood.position.set( -2.2, 0.05, -1.5);
  scene.add(blood);

  // monster
  const mGeo = new THREE.SphereGeometry(0.9, 16, 12);
  const mMat = new THREE.MeshStandardMaterial({color:0x070707, metalness:0.1, roughness:0.6});
  monster = new THREE.Mesh(mGeo, mMat);
  monster.position.set(3.5,1.0,3.5);
  scene.add(monster);

  // subtle tentacles (thin lines)
  for(let i=0;i<4;i++){
    const g = new THREE.CylinderGeometry(0.03,0.03,1.6,8);
    const m = new THREE.Mesh(g, new THREE.MeshStandardMaterial({color:0x050505}));
    m.rotation.z = Math.PI/2;
    m.position.set(monster.position.x + Math.cos(i*1.6)*0.8, 0.8 - (i*0.05), monster.position.z + Math.sin(i*1.6)*0.8);
    scene.add(m);
  }

  window.addEventListener('resize', ()=> {
    if(!renderer) return;
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
  });
}

// monster & simple AI variables
let monster;
let monsterVel = new THREE.Vector3();
let monsterSpeedBase = 0.007;
let idleFrames = 0;

// pointer lock controls
let yaw = 0, pitch = 0;
let keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

document.addEventListener('pointerlockchange', () => {
  // nothing special
});

function requestPointerLock(canvas){
  canvas.requestPointerLock?.();
}
document.addEventListener('mousemove', (e)=>{
  if(document.pointerLockElement){
    yaw -= e.movementX * SENS;
    pitch -= e.movementY * SENS;
    pitch = Math.max(-1.4, Math.min(1.4, pitch));
  }
});

// start a run
function startRun(){
  // reset state
  if(!renderer) initThree();
  document.getElementById('menu').style.display = 'none';
  document.getElementById('game').style.display = 'block';
  hud.style.display = 'block';
  deathOverlay.style.display = 'none';

  // reset gameplay state
  camera.position.set(0,1.6,0);
  yaw = 0; pitch = 0;
  monster.position.set(3.5,1.0,3.5);
  monsterVel.set(0,0,0);
  playerMovedDistance = 0;
  prevPlayerPos.copy(camera.position);
  idleFrames = 0;
  playing = true;
  lastTime = performance.now();
  clockStart = lastTime;
  survivalSeconds = 0;

  // pointer lock
  requestPointerLock(renderer.domElement);
  animate();
}

// animation loop
function animate(now){
  if(!playing) return;
  requestAnimationFrame(animate);

  const dt = Math.min(50, now - lastTime) / 16.666; // ~60fps scale
  lastTime = now;

  // movement
  const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
  const right = new THREE.Vector3(forward.z, 0, -forward.x);

  let moved = false;
  if(keys['w']) { camera.position.addScaledVector(forward, MOVE_SPEED * dt); moved = true; }
  if(keys['s']) { camera.position.addScaledVector(forward, -MOVE_SPEED * dt); moved = true; }
  if(keys['a']) { camera.position.addScaledVector(right, -MOVE_SPEED * dt); moved = true; }
  if(keys['d']) { camera.position.addScaledVector(right, MOVE_SPEED * dt); moved = true; }

  // accumulate movement distance for anti-cheat
  const deltaMoved = camera.position.distanceTo(prevPlayerPos);
  playerMovedDistance += deltaMoved;
  prevPlayerPos.copy(camera.position);

  if(!moved) idleFrames++; else idleFrames = 0;

  // camera rotation
  camera.rotation.set(pitch, yaw, 0);

  // monster behavior:
  // if player NOT looking (angle diff > ~80deg) OR idleFrames high, monster moves toward player
  const toPlayer = new THREE.Vector3().subVectors(camera.position, monster.position);
  const dist = toPlayer.length();
  const monsterDir = toPlayer.clone().normalize();
  const camForward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();
  const angle = Math.abs(monsterDir.angleTo(camForward)); // 0 when in front

  const playerLooks = angle < Math.PI * 0.45; // ~81 degrees
  const shouldAdvance = (!playerLooks && dist < 12) || idleFrames > 120;

  if(shouldAdvance){
    // accelerate toward player
    const speed = monsterSpeedBase * (1 + (1 - Math.min(1, dist/8)) * 3); // faster when close
    monsterVel.addScaledVector(monsterDir, speed * dt * (1 + Math.random()*0.6));
  } else {
    // small wander/damp
    monsterVel.addScaledVector(new THREE.Vector3(Math.cos(now*0.0007+monster.position.x),0,Math.sin(now*0.0009+monster.position.z)), 0.0008 * dt);
    monsterVel.multiplyScalar(0.95);
  }

  // apply velocity
  monster.position.addScaledVector(monsterVel, dt);

  // simple bounds in room
  monster.position.x = Math.max(-4.2, Math.min(4.2, monster.position.x));
  monster.position.z = Math.max(-4.2, Math.min(4.2, monster.position.z));

  // breathing pulsing effect
  monster.scale.setScalar(1 + Math.sin(now*0.004 + monster.position.x)*0.03 * (1 + (1 - Math.min(1, dist/6))));

  // check collision
  if(dist < 0.9 + 0.6){
    // death
    endRun();
    return;
  }

  // update timer & HUD
  survivalSeconds = (now - clockStart) / 1000;
  timeEl.textContent = survivalSeconds.toFixed(1);
  sanEl.textContent = (Math.max(0.05, 1 - (Math.max(0, 5 - Math.min(5, survivalSeconds))/8))).toFixed(2);

  renderer.render(scene, camera);
}

// end run (player died)
function endRun(){
  playing = false;
  hud.style.display = 'none';
  deathOverlay.style.display = 'flex';
  finalTime.textContent = survivalSeconds.toFixed(2);
  submitNote.textContent = '';
  // grab session flag again
  submittedThisSession = sessionStorage.getItem('scary_submitted') === '1';
  // prefill name with creepy default
  playerNameInput.value = `PATIENT_${Math.floor(Math.random()*9999)}`;
}

// submission + anti-cheat
submitBtn.onclick = async ()=>{
  if(submittedThisSession){
    submitNote.textContent = 'You already submitted a score this session.';
    return;
  }

  const name = (playerNameInput.value || '').trim().slice(0,18) || `ANON_${Math.floor(Math.random()*9999)}`;
  let score = Math.floor(survivalSeconds);
  // Anti-cheat checks (client-side)
  if(score < MIN_SURVIVAL){
    submitNote.textContent = `Survive at least ${MIN_SURVIVAL}s to submit. (${score}s)`;
    return;
  }
  if(playerMovedDistance < 1.6){
    submitNote.textContent = 'You must move during the run (no teleport/spam).';
    return;
  }
  // clamp
  if(score > MAX_SCORE) score = MAX_SCORE;

  // simple token/extra for later server-side validation (not secure but slightly helpful)
  const extras = { sessionId, movementDistance: Math.round(playerMovedDistance), clientNote: 'client-side-v1' };

  try{
    await window.submitScore(name, score, extras);
    sessionStorage.setItem('scary_submitted', '1');
    submittedThisSession = true;
    submitNote.textContent = 'Submitted! Showing leaderboard...';
    // refresh leaderboard then show
    setTimeout(()=>{ openLeaderboard(true); }, 700);
  } catch(err){
    console.error(err);
    submitNote.textContent = 'Submit failed. Check console.';
  }
};

// play again
playAgainBtn.onclick = ()=>{
  deathOverlay.style.display = 'none';
  startRun();
};

/* ============================
   LEADERBOARD UI
   ============================ */
async function openLeaderboard(afterSubmit=false){
  leaderPanel.style.display = 'block';
  leaderList.innerHTML = '<li>LOADING...</li>';
  menu.style.display = 'flex';

  try{
    const data = await window.loadLeaderboard();
    leaderList.innerHTML = '';
    if(!data.length) leaderList.innerHTML = '<li>[NO RECORDS]</li>';
    // highlight your session entries
    data.forEach(d=>{
      const li = document.createElement('li');
      let text = `${d.name} — ${d.score}s`;
      li.textContent = text;
      // if matches our sessionId (we stored extras.sessionId on submit) highlight
      if(d.sessionId && d.sessionId === sessionId){
        li.style.color = '#ff9b9b';
        li.textContent += ' (YOU)';
      }
      leaderList.appendChild(li);
    });
    // if called after submit, auto-close death overlay
    if(afterSubmit) deathOverlay.style.display = 'none';
  } catch(e){
    console.error(e);
    leaderList.innerHTML = '<li>LOAD ERROR</li>';
  }
}
function closeLeaderboard(){
  leaderPanel.style.display = 'none';
}

/* expose some debug helpers to console */
window._scary = {
  startRun, endRun, monster, getState: ()=>({ survivalSeconds, playerMovedDistance, sessionId, submittedThisSession })
};

</script>

</body>
</html>
