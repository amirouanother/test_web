/* ============================
   SIMPLE GAME (Three.js first-person) â€” FIXED MAP + MONSTER
   ============================ */

import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

let renderer, scene, camera;
let playing = false;
let lastTime = 0;
let clockStart = 0;
let survivalSeconds = 0;
let playerMovedDistance = 0;
let prevPlayerPos = new THREE.Vector3();

const MOVE_SPEED = 0.035;
const SENS = 0.0022;

let monster, monsterVel = new THREE.Vector3();
let idleFrames = 0;

function initThree(){
  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(devicePixelRatio);
  document.getElementById('game').appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050507);
  scene.fog = new THREE.Fog(0x050507, 6, 22);

  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 100);
  camera.position.set(0, 1.6, 6);

  /* LIGHTING */
  scene.add(new THREE.AmbientLight(0x404040, 0.4));

  const flicker = new THREE.PointLight(0xfff2cc, 1.1, 18);
  flicker.position.set(0, 3.5, 0);
  scene.add(flicker);

  setInterval(()=>{
    flicker.intensity = 0.8 + Math.random()*0.6;
  }, 120);

  /* === MAP === */
  const wallMat = new THREE.MeshStandardMaterial({
    color: 0x1a1a1a,
    roughness: 0.95
  });

  const floorMat = new THREE.MeshStandardMaterial({
    color: 0x111111,
    roughness: 1
  });

  // Floor
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(40, 40),
    floorMat
  );
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  // Ceiling
  const ceiling = new THREE.Mesh(
    new THREE.PlaneGeometry(40, 40),
    wallMat
  );
  ceiling.rotation.x = Math.PI/2;
  ceiling.position.y = 4;
  scene.add(ceiling);

  // Corridor walls
  function wall(x,z,w,h,rot=0){
    const m = new THREE.Mesh(
      new THREE.BoxGeometry(w, h, 0.4),
      wallMat
    );
    m.position.set(x, h/2, z);
    m.rotation.y = rot;
    scene.add(m);
  }

  // Main hallway
  wall(-3, 0, 20, 4);
  wall( 3, 0, 20, 4);

  // End walls
  wall(0, -10, 6, 4, Math.PI/2);
  wall(0, 10, 6, 4, Math.PI/2);

  // Side room
  wall(8, 0, 12, 4);
  wall(12, 0, 12, 4);
  wall(10, -6, 4, 4, Math.PI/2);

  /* === MONSTER MODEL === */
  monster = new THREE.Group();

  const bodyMat = new THREE.MeshStandardMaterial({
    color: 0x080808,
    roughness: 0.6
  });

  const torso = new THREE.Mesh(
    new THREE.BoxGeometry(0.8, 1.2, 0.4),
    bodyMat
  );
  torso.position.y = 1.4;

  const head = new THREE.Mesh(
    new THREE.SphereGeometry(0.35, 16, 16),
    bodyMat
  );
  head.position.y = 2.2;

  // Eyes
  const eyeMat = new THREE.MeshStandardMaterial({ color: 0xff2222, emissive:0x550000 });
  const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.05,8,8), eyeMat);
  const eyeR = eyeL.clone();
  eyeL.position.set(-0.12, 2.25, 0.32);
  eyeR.position.set( 0.12, 2.25, 0.32);

  const legGeo = new THREE.BoxGeometry(0.2, 1, 0.2);
  const legL = new THREE.Mesh(legGeo, bodyMat);
  const legR = legL.clone();
  legL.position.set(-0.2, 0.5, 0);
  legR.position.set( 0.2, 0.5, 0);

  monster.add(torso, head, eyeL, eyeR, legL, legR);
  monster.position.set(0, 0, -6);
  scene.add(monster);

  window.addEventListener('resize', ()=>{
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
  });
}

/* INPUT */
let yaw = 0, pitch = 0;
let keys = {};
addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

addEventListener('mousemove', e=>{
  if(document.pointerLockElement){
    yaw -= e.movementX * SENS;
    pitch -= e.movementY * SENS;
    pitch = Math.max(-1.4, Math.min(1.4, pitch));
  }
});

/* START GAME */
function startRun(){
  if(!renderer) initThree();

  document.getElementById('menu').style.display = 'none';
  document.getElementById('game').style.display = 'block';
  hud.style.display = 'block';

  camera.position.set(0,1.6,6);
  yaw = 0; pitch = 0;
  monster.position.set(0,0,-8);
  monsterVel.set(0,0,0);
  idleFrames = 0;
  survivalSeconds = 0;
  playerMovedDistance = 0;
  prevPlayerPos.copy(camera.position);

  playing = true;
  lastTime = performance.now();
  clockStart = lastTime;

  renderer.domElement.requestPointerLock();
  animate();
}

/* LOOP */
function animate(now){
  if(!playing) return;
  requestAnimationFrame(animate);

  const dt = Math.min(50, now-lastTime)/16.666;
  lastTime = now;

  const forward = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
  const right = new THREE.Vector3(forward.z,0,-forward.x);

  let moved=false;
  if(keys.w){ camera.position.addScaledVector(forward, MOVE_SPEED*dt); moved=true; }
  if(keys.s){ camera.position.addScaledVector(forward,-MOVE_SPEED*dt); moved=true; }
  if(keys.a){ camera.position.addScaledVector(right,-MOVE_SPEED*dt); moved=true; }
  if(keys.d){ camera.position.addScaledVector(right, MOVE_SPEED*dt); moved=true; }

  playerMovedDistance += camera.position.distanceTo(prevPlayerPos);
  prevPlayerPos.copy(camera.position);
  idleFrames = moved ? 0 : idleFrames+1;

  camera.rotation.set(pitch,yaw,0);

  /* MONSTER AI */
  const toPlayer = new THREE.Vector3().subVectors(camera.position, monster.position);
  const dist = toPlayer.length();
  const dir = toPlayer.normalize();

  const camDir = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
  const looking = dir.angleTo(camDir) < Math.PI*0.45;

  if(!looking || idleFrames > 120){
    monsterVel.addScaledVector(dir, 0.01*dt);
  } else {
    monsterVel.multiplyScalar(0.9);
  }

  monster.position.addScaledVector(monsterVel, dt);
  monster.lookAt(camera.position);

  if(dist < 0.8){
    endRun();
    return;
  }

  survivalSeconds = (now-clockStart)/1000;
  timeEl.textContent = survivalSeconds.toFixed(1);

  renderer.render(scene, camera);
}
